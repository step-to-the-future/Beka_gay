<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Quiz Test</title>
<style>
body {
  font-family: Arial, sans-serif;
  margin: 0;
  height: 100vh;
  background: #f0f0f0;
  display: flex;
}

#quiz-container {
  width: 50%;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  padding: 40px 20px;
  box-sizing: border-box;
}

#sidebar {
  width: 50%;
  display: flex;
  justify-content: center;
  align-items: center;
  box-sizing: border-box;
}

#circle-box {
  width: 650px;        /* fixed square width */
  height: 700px;       /* fixed square height */
  background: #fff;
  border: 1px solid #ddd;
  border-radius: 25px;
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  align-content: center;
  padding: 10px;
  box-sizing: border-box;
  overflow-y: auto;
}

.circle {
  width: 45px;
  height: 45px;
  border-radius: 15%; 
  background: #ccc;
  margin: 5px;
}

.correct { background-color: #4CAF50 !important; }
.wrong { background-color: #f44336 !important; }

.question { font-weight: bold; margin-bottom: 20px; font-size: 2rem; }
.answers label {
  display: block;
  margin: 8px 0;
  font-size: 1.2rem;
  padding: 10px;
  border-radius: 5px;
  cursor: pointer;
  border: 1px solid #ccc;
  transition: background 0.3s;
}
.answers input { margin-right: 10px; }
.answers label.correct { background-color: #4CAF50; color: #fff; border-color: #4CAF50; }
.answers label.wrong { background-color: #f44336; color: #fff; border-color: #f44336; }

button {
  margin-top: 20px;
  padding: 10px 30px;
  font-size: 1em;
  cursor: pointer;
  border: none;
  border-radius: 5px;
  background: #2196F3;
  color: #fff;
  transition: background 0.3s;
}
button:disabled { background: #aaa; cursor: not-allowed; }
button:hover:not(:disabled) { background: #1976D2; }

#result { font-weight: bold; margin-top: 20px; text-align: center; }

/* =========================
   RESPONSIVE (PHONES)
   ========================= */
@media (max-width: 768px) {

  body {
    flex-direction: column;
    height: auto;
  }

  #quiz-container,
  #sidebar {
    width: 100%;
    padding: 20px 15px;
  }

  #sidebar {
    order: 2;
  }

  #quiz-container {
    order: 1;
  }

  /* Circle box becomes responsive */
  #circle-box {
    width: 100%;
    max-width: 100%;
    height: 500px;
    border-radius: 20px;
  }

  .circle {
    width: 35px;
    height: 35px;
    margin: 4px;
  }

  .correct { background-color: #4CAF50 !important; }
.wrong { background-color: #f44336 !important; }
  
  .question {
    font-size: 1.5rem;
    text-align: center;
  }

  .answers label {
    font-size: 1rem;
    padding: 8px;
  }

  button {
    width: 100%;
    font-size: 1.1rem;
    padding: 12px;
  }

  #result {
    font-size: 1.1rem;
  }
}

  
</style>
</head>
<body>

<div id="quiz-container">
  <div id="quiz"></div>
  <button id="nextBtn" disabled>Next</button>
  <div id="result"></div>
</div>

<div id="sidebar">
  <div id="circle-box"></div>
</div>

<script>
// Example subset; replace with all your questions
const quizData = [
  
// here will be the test 


  {
    q: "Цикл — это",
    a: [
      "Однократное выполнение команды",
      "Проверка условия без выполнения кода",
      "Последовательность независимых инструкций",
      "Многократное выполнение блока команд/действий"
    ],
    c: 3
  },
  {
    q: "Какой цикл в C++ выполняется хотя бы один раз, даже если условие ложно?",
    a: [
      "while",
      "for",
      "foreach",
      "do while"
    ],
    c: 3
  },
  {
    q: "Ключевое слово для счётного цикла в C++",
    a: [
      "while",
      "repeat",
      "loop",
      "for"
    ],
    c: 3
  },
  {
    q: "Бесконечный цикл — это",
    a: [
      "Цикл с фиксированным числом повторений",
      "Цикл, выполняющийся один раз",
      "Цикл с условием выхода",
      "Многократное выполнение блока команд/действий"
    ],
    c: 3
  },
  {
    q: "Какой оператор используется для принудительного выхода из цикла?",
    a: [
      "exit",
      "stop",
      "continue",
      "break"
    ],
    c: 3
  },
  {
    q: "Что делает оператор continue в цикле?",
    a: [
      "Завершает выполнение программы",
      "Полностью выходит из цикла",
      "Повторяет текущую итерацию",
      "Пропускает текущую итерацию и переходит к следующей"
    ],
    c: 3
  },
  {
    q: "Временная сложность вложенного цикла из двух циклов по n раз",
    a: [
      "O(n)",
      "O(log n)",
      "O(2n)",
      "O(n²)"
    ],
    c: 3
  },
  {
    q: "Факториал числа можно вычислить",
    a: [
      "Только с помощью цикла",
      "Только с помощью массива",
      "Только с помощью условия",
      "Циклом или рекурсией"
    ],
    c: 3
  },
  {
    q: "Что удобнее всего использовать для обхода графа в ширину (BFS)?",
    a: [
      "Стек",
      "Массив",
      "Рекурсию",
      "Очередь"
    ],
    c: 3
  },
  {
    q: "Как сортировка пузырьком работает?",
    a: [
      "Делит массив на части",
      "Выбирает минимальный элемент",
      "Использует рекурсию",
      "Многократно сравнивает соседние элементы и меняет местами при необходимости"
    ],
    c: 3
  },
  {
    q: "Как проверить, является ли число чётным в C++?",
    a: [
      "x / 2 == 0",
      "x % 2 == 1",
      "x == 2",
      "x % 2 == 0"
    ],
    c: 3
  },
  {
    q: "Как найти максимальное число в массиве?",
    a: [
      "Отсортировать массив",
      "Взять первый элемент",
      "Использовать формулу",
      "Пройти по массиву и хранить текущий максимум"
    ],
    c: 3
  },
  {
    q: "Формула для суммы чисел от 1 до n",
    a: [
      "n²",
      "n(n−1)/2",
      "2n",
      "n(n+1)/2"
    ],
    c: 3
  },
  {
    q: "Средняя временная сложность быстрой сортировки",
    a: [
      "O(n²)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ],
    c: 3
  },
  {
    q: "Какой метод использует быстрая сортировка для разбиения массива",
    a: [
      "Сравнение соседних элементов",
      "Слияние подмассивов",
      "Последовательный обход",
      "Использование опорного элемента"
    ],
    c: 3
  },
  {
    q: "Сортировка слиянием является",
    a: [
      "Нестабильной",
      "Медленной сортировкой",
      "Квадратичной по сложности",
      "Стабильной сортировкой"
    ],
    c: 3
  },
  {
    q: "Почему сортировка пузырьком неэффективна",
    a: [
      "Использует много памяти",
      "Работает только с числами",
      "Не сравнивает элементы",
      "Из-за квадратичной сложности O(n²) и большого числа сравнений"
    ],
    c: 3
  },
  {
    q: "Какой алгоритм эффективен для почти отсортированных данных",
    a: [
      "Быстрая сортировка",
      "Пузырьковая сортировка",
      "Поразрядная сортировка",
      "Сортировка вставками"
    ],
    c: 3
  },
  {
    q: "Быстрая сортировка в лучшем случае работает за",
    a: [
      "O(n²)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ],
    c: 3
  },
  {
    q: "Поразрядная сортировка сортирует элементы",
    a: [
      "По убыванию значений",
      "По возрастанию индексов",
      "По длине массива",
      "По разрядам (цифрам)"
    ],
    c: 3
  },
  {
    q: "Быстрая сортировка является",
    a: [
      "Линейным алгоритмом сортировки",
      "Стабильным алгоритмом сортировки",
      "Алгоритмом полного перебора",
      "Алгоритмом сортировки «разделяй и властвуй»; обычно нестабильным"
    ],
    c: 3
  },
  {
    q: "На чём основана пирамидальная сортировка",
    a: [
      "На связном списке",
      "На массиве с линейным поиском",
      "На рекурсии",
      "На двоичной куче (heap)"
    ],
    c: 3
  },
  {
    q: "Сортировка слиянием требует",
    a: [
      "Минимальное количество памяти",
      "Постоянную память O(1)",
      "Только стек вызовов",
      "Дополнительную память O(n)"
    ],
    c: 3
  },
  {
    q: "Сортировка слиянием лучше подходит для",
    a: [
      "Маленьких массивов",
      "Почти отсортированных данных",
      "Случайных данных без ограничений",
      "Больших массивов и внешней сортировки; когда нужна стабильность"
    ],
    c: 3
  },
  {
    q: "Сортировка выбором выполняет минимальное количество",
    a: [
      "Сравнений",
      "Итераций",
      "Копирований",
      "Обменов (swap)"
    ],
    c: 3
  },
  {
    q: "Сортировка слиянием выполняет меньше всего",
    a: [
      "Проходов по массиву",
      "Перестановок элементов",
      "Использований памяти",
      "Сравнений (по сравнению с простыми O(n²) сортировками)"
    ],
    c: 3
  },
  {
    q: "Средняя временная сложность быстрой сортировки",
    a: [
      "O(n²)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ],
    c: 3
  },
  {
    q: "Какой метод использует быстрая сортировка для разбиения массива",
    a: [
      "Сравнение соседних элементов",
      "Слияние подмассивов",
      "Линейный поиск",
      "Использование опорного элемента (pivot)"
    ],
    c: 3
  },
  {
    q: "Сортировка слиянием является",
    a: [
      "Нестабильной",
      "Квадратичной",
      "Внутренней сортировкой",
      "Стабильной сортировкой"
    ],
    c: 3
  },
  {
    q: "Почему сортировка пузырьком неэффективна",
    a: [
      "Требует много памяти",
      "Работает только с числами",
      "Не использует оптимизацию",
      "Из-за квадратичной сложности O(n²) и большого числа сравнений/обменов"
    ],
    c: 3
  },
  {
    q: "Какой алгоритм эффективен для почти отсортированных данных",
    a: [
      "Быстрая сортировка",
      "Сортировка выбором",
      "Пузырьковая сортировка",
      "Сортировка вставками"
    ],
    c: 3
  },
  {
    q: "Быстрая сортировка в лучшем случае работает за",
    a: [
      "O(n²)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ],
    c: 3
  },
  {
    q: "Поразрядная сортировка сортирует элементы",
    a: [
      "По убыванию значений",
      "По индексу в массиве",
      "По длине массива",
      "По разрядам (цифрам) — от младшего к старшему или наоборот"
    ],
    c: 3
  },
  {
    q: "Быстрая сортировка является",
    a: [
      "Медленным алгоритмом сортировки",
      "Алгоритмом с линейной сложностью",
      "Всегда стабильным алгоритмом",
      "Алгоритмом сортировки «разделяй и властвуй»; обычно нестабильным"
    ],
    c: 3
  },
  {
    q: "На чём основана пирамидальная сортировка",
    a: [
      "На стеке",
      "На очереди",
      "На рекурсивных вызовах",
      "На двоичной куче (heap)"
    ],
    c: 3
  },
  {
    q: "Сортировка слиянием требует",
    a: [
      "Постоянную память",
      "Минимальное количество памяти",
      "Только временные переменные",
      "Дополнительную память O(n)"
    ],
    c: 3
  },
  {
    q: "Сортировка слиянием лучше подходит для",
    a: [
      "Малых массивов",
      "Почти отсортированных данных",
      "Массивов без повторений",
      "Больших массивов и внешней сортировки; когда нужна стабильность"
    ],
    c: 3
  },
  {
    q: "Сортировка выбором выполняет минимальное количество",
    a: [
      "Сравнений",
      "Проходов",
      "Проверок условий",
      "Обменов (swap)"
    ],
    c: 3
  },
  {
    q: "Сортировка слиянием выполняет меньше всего",
    a: [
      "Перестановок",
      "Итераций",
      "Использований памяти",
      "Сравнений (по сравнению с простыми O(n²) сортировками)"
    ],
    c: 3
  },
  {
    q: "Средняя временная сложность быстрой сортировки",
    a: [
      "O(n²)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ],
    c: 3
  },
  {
    q: "Какой метод использует быстрая сортировка для разбиения массива",
    a: [
      "Последовательный обход",
      "Сравнение всех элементов",
      "Слияние частей массива",
      "Выбор опорного элемента"
    ],
    c: 3
  },
  {
    q: "Сортировка слиянием является",
    a: [
      "Нестабильной",
      "Медленной",
      "Квадратичной",
      "Стабильной сортировкой"
    ],
    c: 3
  },
  {
    q: "Почему сортировка пузырьком неэффективна",
    a: [
      "Использует рекурсию",
      "Требует много памяти",
      "Не подходит для чисел",
      "Из-за квадратичной сложности O(n²) и большого числа сравнений/обменов"
    ],
    c: 3
  },
  {
    q: "Какой алгоритм эффективен для почти отсортированных данных",
    a: [
      "Быстрая сортировка",
      "Сортировка выбором",
      "Пузырьковая сортировка",
      "Сортировка вставками"
    ],
    c: 3
  },
  {
    q: "Быстрая сортировка в лучшем случае работает за",
    a: [
      "O(n²)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ],
    c: 3
  },


  {
    q: "Поразрядная сортировка сортирует элементы",
    a: [
      "По убыванию значений",
      "По индексу в массиве",
      "По размеру массива",
      "По разрядам (цифрам) — от младшего к старшему или наоборот"
    ],
    c: 3
  },
  {
    q: "Быстрая сортировка является",
    a: [
      "Стабильным алгоритмом",
      "Линейным алгоритмом",
      "Алгоритмом полного перебора",
      "Алгоритмом сортировки «разделяй и властвуй»; обычно нестабильным"
    ],
    c: 3
  },
  {
    q: "На чём основана пирамидальная сортировка",
    a: [
      "На стеке",
      "На очереди",
      "На рекурсии",
      "На двоичной куче (heap)"
    ],
    c: 3
  },
  {
    q: "Сортировка слиянием требует",
    a: [
      "Постоянную память O(1)",
      "Минимальное количество памяти",
      "Только локальные переменные",
      "Дополнительную память O(n)"
    ],
    c: 3
  },
  {
    q: "Сортировка слиянием лучше подходит для",
    a: [
      "Маленьких массивов",
      "Почти отсортированных данных",
      "Внутренней сортировки",
      "Больших массивов и внешней сортировки; когда нужна стабильность"
    ],
    c: 3
  },
  {
    q: "Сортировка выбором выполняет минимальное количество",
    a: [
      "Сравнений",
      "Проходов",
      "Проверок условий",
      "Обменов (swap)"
    ],
    c: 3
  },
  {
    q: "Сортировка слиянием выполняет меньше всего",
    a: [
      "Перестановок",
      "Итераций",
      "Использований памяти",
      "Сравнений (по сравнению с простыми O(n²) сортировками)"
    ],
    c: 3
  },
  {
    q: "Что такое алгоритм?",
    a: [
      "Набор случайных действий",
      "Программа на языке программирования",
      "Описание задачи",
      "Конечная, упорядоченная последовательность действий для решения задачи"
    ],
    c: 3
  },
  {
    q: "Какие свойства должен иметь алгоритм?",
    a: [
      "Быстрота и компактность",
      "Минимальный объём памяти",
      "Использование циклов",
      "Определённость, конечность, результативность"
    ],
    c: 3
  },
  {
    q: "Сколько основных видов алгоритмов существует?",
    a: [
      "Два",
      "Четыре",
      "Пять",
      "Три: линейные, разветвляющиеся, циклические"
    ],
    c: 3
  },
  {
    q: "Какие виды алгоритмов существуют?",
    a: [
      "Простые и сложные",
      "Быстрые и медленные",
      "Внутренние и внешние",
      "Линейные, с ветвлением, циклические"
    ],
    c: 3
  },
  {
    q: "Что представляет собой линейный алгоритм?",
    a: [
      "Алгоритм с циклами",
      "Алгоритм с условиями",
      "Алгоритм с рекурсией",
      "Последовательное выполнение команд без ветвлений и циклов"
    ],
    c: 3
  },
  {
    q: "Как в алгоритме организуется ветвление?",
    a: [
      "С помощью циклов",
      "С помощью функций",
      "С помощью массивов",
      "С помощью условий (if/else)"
    ],
    c: 3
  },
  {
    q: "Что такое цикл в алгоритме?",
    a: [
      "Однократное выполнение действий",
      "Случайный выбор команд",
      "Завершение алгоритма",
      "Повторение блока действий по условию"
    ],
    c: 3
  },
  {
    q: "Что такое циклический алгоритм?",
    a: [
      "Алгоритм без условий",
      "Алгоритм без повторений",
      "Алгоритм с рекурсией",
      "Алгоритм, содержащий циклы"
    ],
    c: 3
  },
  {
    q: "Что такое рекурсия?",
    a: [
      "Повторение команд в цикле",
      "Ветвление алгоритма",
      "Последовательный вызов функций",
      "Способ решения, когда функция вызывает саму себя"
    ],
    c: 3
  },
  {
    q: "При разветвлении алгоритм делает",
    a: [
      "Выполняет все варианты",
      "Повторяет действия",
      "Завершает работу",
      "Выбирает один из вариантов действий по условию"
    ],
    c: 3
  },
  {
    q: "Что называют циклом?",
    a: [
      "Одно действие",
      "Последовательность без условий",
      "Завершение программы",
      "Повторение действий до наступления условия завершения"
    ],
    c: 3
  },
  {
    q: "Какова основная цель алгоритма?",
    a: [
      "Использовать меньше памяти",
      "Работать быстрее",
      "Быть короче",
      "Получить правильный результат"
    ],
    c: 3
  },
  {
    q: "Как можно представить алгоритм?",
    a: [
      "Только программным кодом",
      "Только формулой",
      "Только таблицей",
      "Текстом, псевдокодом, блок-схемой"
    ],
    c: 3
  },
  {
    q: "Почему линейный алгоритм всегда выполняется одинаково?",
    a: [
      "Потому что он короткий",
      "Потому что он быстрый",
      "Потому что нет входных данных",
      "Потому что нет условий и циклов"
    ],
    c: 3
  },
  {
    q: "Что обозначает блок в блок-схеме алгоритма?",
    a: [
      "Весь алгоритм",
      "Ошибку выполнения",
      "Переменную",
      "Отдельную операцию или действие"
    ],
    c: 3
  },
  {
    q: "Что такое алгоритм?",
    a: [
      "Список команд компьютера",
      "Программа на C++",
      "Формула",
      "Конечная, упорядоченная последовательность действий для решения задачи"
    ],
    c: 3
  },
  {
    q: "Линейный алгоритм выполняется",
    a: [
      "Случайным образом",
      "С возвратами назад",
      "С проверкой условий",
      "Последовательно, шаг за шагом"
    ],
    c: 3
  },
  {
    q: "Какие три свойства должен иметь алгоритм?",
    a: [
      "Быстрота, простота, компактность",
      "Гибкость, масштабируемость, точность",
      "Использование циклов и условий",
      "Определённость, конечность, результативность"
    ],
    c: 3
  },

  {
    q: "Основная цель алгоритма",
    a: [
      "Минимизировать код",
      "Использовать меньше памяти",
      "Быть универсальным",
      "Получить правильный результат"
    ],
    c: 3
  },
  {
    q: "Как можно представить алгоритм?",
    a: [
      "Только блок-схемой",
      "Только текстом",
      "Только псевдокодом",
      "Текстом, псевдокодом, блок-схемой"
    ],
    c: 3
  },
  {
    q: "Что такое ветвление в алгоритме?",
    a: [
      "Повторение действий",
      "Последовательное выполнение",
      "Завершение алгоритма",
      "Выбор одного из путей выполнения по условию"
    ],
    c: 3
  },
  {
    q: "Какой оператор используется для ветвления?",
    a: [
      "for",
      "while",
      "switch only",
      "if (if/else)"
    ],
    c: 3
  },
  {
    q: "Что такое циклический алгоритм?",
    a: [
      "Алгоритм без условий",
      "Алгоритм без повторений",
      "Алгоритм без входных данных",
      "Алгоритм, содержащий циклы"
    ],
    c: 3
  },
  {
    q: "Цикл в алгоритме — это",
    a: [
      "Однократное действие",
      "Выбор варианта",
      "Завершение программы",
      "Повторение блока действий по условию"
    ],
    c: 3
  },
  {
    q: "Что такое рекурсия?",
    a: [
      "Вид сортировки",
      "Вид цикла",
      "Вид ветвления",
      "Вызов функцией самой себя"
    ],
    c: 3
  },
  {
    q: "Линейный алгоритм всегда выполняется",
    a: [
      "По условию",
      "С повторениями",
      "С ветвлением",
      "Последовательно"
    ],
    c: 3
  },
  {
    q: "При разветвлении алгоритм выбирает",
    a: [
      "Все варианты сразу",
      "Случайный путь",
      "Последний вариант",
      "Один из вариантов действий по условию"
    ],
    c: 3
  },
  {
    q: "Блок в блок-схеме обозначает",
    a: [
      "Условие",
      "Начало алгоритма",
      "Конец алгоритма",
      "Операцию или действие"
    ],
    c: 3
  },
  {
    q: "Для чего используется рекурсия?",
    a: [
      "Для ускорения сортировки",
      "Для уменьшения памяти",
      "Для работы с массивами",
      "Для задач, разбиваемых на подзадачи того же типа"
    ],
    c: 3
  },
  {
    q: "Цель цикла",
    a: [
      "Однократное выполнение действий",
      "Завершение программы",
      "Выбор одного варианта",
      "Многократное выполнение блока действий"
    ],
    c: 3
  },
  {
    q: "Цикл можно использовать для",
    a: [
      "Описания данных",
      "Объявления переменных",
      "Завершения алгоритма",
      "Повторяющихся вычислений и операций"
    ],
    c: 3
  },
  {
    q: "break используется для",
    a: [
      "Перехода к следующей итерации",
      "Повтора цикла",
      "Проверки условия",
      "Немедленного выхода из цикла"
    ],
    c: 3
  },
  {
    q: "continue используется для",
    a: [
      "Полного завершения цикла",
      "Завершения программы",
      "Возврата к началу программы",
      "Перехода к следующей итерации, пропуская остаток тела"
    ],
    c: 3
  },
  {
    q: "Цикл while проверяет условие",
    a: [
      "После выполнения программы",
      "В середине цикла",
      "После каждой функции",
      "Перед выполнением тела цикла"
    ],
    c: 3
  },
  {
    q: "Цикл do while проверяет условие",
    a: [
      "До входа в цикл",
      "Перед каждой итерацией",
      "В начале программы",
      "После выполнения тела цикла"
    ],
    c: 3
  },
  {
    q: "Счётный цикл for содержит",
    a: [
      "Только условие",
      "Только шаг",
      "Только инициализацию",
      "Инициализацию, условие и шаг"
    ],
    c: 3
  },
  {
    q: "Вложенный цикл — это",
    a: [
      "Цикл без условия",
      "Однократное выполнение цикла",
      "Рекурсивный вызов",
      "Цикл, расположенный внутри другого цикла"
    ],
    c: 3
  },
  {
    q: "Цикл while — это",
    a: [
      "Цикл без условия",
      "Цикл с фиксированным числом повторений",
      "Цикл с проверкой после итерации",
      "Цикл с проверкой условия перед итерацией"
    ],
    c: 3
  },
  {
    q: "Цикл do while — это",
    a: [
      "Цикл без условий",
      "Цикл без повторений",
      "Цикл с проверкой перед выполнением",
      "Цикл с проверкой условия после итерации"
    ],
    c: 3
  },
  {
    q: "Линейный алгоритм представляет собой",
    a: [
      "Алгоритм с циклами",
      "Алгоритм с ветвлениями",
      "Алгоритм с рекурсией",
      "Последовательное выполнение команд без ветвлений и циклов"
    ],
    c: 3
  },
  {
    q: "Циклический алгоритм выполняет операции",
    a: [
      "Только один раз",
      "В случайном порядке",
      "Без условий",
      "Повторно, с использованием циклов"
    ],
    c: 3
  },
  {
    q: "Рекурсивный алгоритм может быть использован для",
    a: [
      "Линейных вычислений",
      "Простых условий",
      "Сортировки пузырьком",
      "Задач, разбиваемых на подзадачи того же типа"
    ],
    c: 3
  },
  {
    q: "Блок-схема помогает",
    a: [
      "Ускорить выполнение программы",
      "Написать код автоматически",
      "Найти ошибки компиляции",
      "Наглядно представить логику алгоритма"
    ],
    c: 3
  },
  {
    q: "Алгоритм с ветвлением делает",
    a: [
      "Повторяет действия",
      "Выполняет все варианты",
      "Завершается сразу",
      "Выполняет один из вариантов по условию"
    ],
    c: 3
  },
  {
    q: "Средняя временная сложность быстрой сортировки",
    a: [
      "O(n²)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ],
    c: 3
  },
  {
    q: "Метод, используемый в быстрой сортировке",
    a: [
      "Слияние массивов",
      "Сравнение соседних элементов",
      "Полный перебор",
      "Разделение по опорному элементу (partition)"
    ],
    c: 3
  },
  {
    q: "Быстрая сортировка является",
    a: [
      "Стабильным алгоритмом",
      "Линейным алгоритмом",
      "Квадратичной сортировкой",
      "Алгоритмом «разделяй и властвуй», обычно нестабильным"
    ],
    c: 3
  },
  {
    q: "Быстрая сортировка в лучшем случае работает за",
    a: [
      "O(n²)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ],
    c: 3
  },

  {
    q: "Сортировка слиянием является",
    a: [
      "Нестабильной",
      "Внутренней сортировкой",
      "Квадратичной",
      "Стабильной сортировкой"
    ],
    c: 3
  },
  {
    q: "Сортировка слиянием требует",
    a: [
      "Постоянную память",
      "Минимальное количество памяти",
      "Только стек вызовов",
      "Дополнительную память O(n)"
    ],
    c: 3
  },
  {
    q: "Сортировка слиянием лучше подходит для",
    a: [
      "Малых массивов",
      "Почти отсортированных данных",
      "Внутренней сортировки",
      "Больших массивов и внешней сортировки"
    ],
    c: 3
  },
  {
    q: "Сортировка вставками эффективна для",
    a: [
      "Больших неотсортированных массивов",
      "Случайных данных",
      "Внешней сортировки",
      "Почти отсортированных данных"
    ],
    c: 3
  },
  {
    q: "Поразрядная сортировка работает",
    a: [
      "Путём сравнения элементов",
      "Через рекурсию",
      "Через обмен соседних элементов",
      "Группируя элементы по разрядам"
    ],
    c: 3
  },
  {
    q: "Пирамидальная сортировка основана на",
    a: [
      "Стеке",
      "Очереди",
      "Связном списке",
      "Двоичной куче (heap)"
    ],
    c: 3
  },
  {
    q: "Сортировка выбором выполняет минимальное количество",
    a: [
      "Сравнений",
      "Проходов",
      "Итераций",
      "Обменов (swap)"
    ],
    c: 3
  },
  {
    q: "Сортировка слиянием выполняет меньше всего",
    a: [
      "Перестановок",
      "Итераций",
      "Использований памяти",
      "Сравнений (по сравнению с O(n²))"
    ],
    c: 3
  },
  {
    q: "Сортировка пузырьком имеет худшую сложность",
    a: [
      "O(n log n)",
      "O(n)",
      "O(log n)",
      "O(n²)"
    ],
    c: 3
  },
  {
    q: "Быстрая сортировка использует",
    a: [
      "Слияние массивов",
      "Сравнение соседних элементов",
      "Линейный поиск",
      "Опорный элемент (pivot) и разбиение массива"
    ],
    c: 3
  },
  {
    q: "Метод «разделяй и властвуй» применяется в",
    a: [
      "Пузырьковой сортировке",
      "Сортировке выбором",
      "Сортировке вставками",
      "Быстрой сортировке и сортировке слиянием"
    ],
    c: 3
  },
  {
    q: "Сортировка вставками минимизирует",
    a: [
      "Количество сравнений",
      "Использование памяти",
      "Количество проходов",
      "Количество перемещений элементов"
    ],
    c: 3
  },
  {
    q: "Быстрая сортировка плохо подходит для",
    a: [
      "Больших массивов",
      "Почти отсортированных данных",
      "Случайных данных",
      "Массивов с уже упорядоченными данными при плохом выборе pivot"
    ],
    c: 3
  },
  {
    q: "Слияние сортирует массив за",
    a: [
      "O(n²)",
      "O(n)",
      "O(log n)",
      "O(n log n)"
    ],
    c: 3
  },
  {
    q: "Пирамидальная сортировка выбирает",
    a: [
      "Случайный элемент",
      "Средний элемент массива",
      "Опорный элемент",
      "Максимальный или минимальный элемент из кучи"
    ],
    c: 3
  },
  {
    q: "Быстрая сортировка изменяет порядок одинаковых элементов, поэтому она",
    a: [
      "Стабильная",
      "Линейная",
      "Квадратичная",
      "Нестабильная"
    ],
    c: 3
  },
  {
    q: "Сортировка выбором находит минимум и ставит его на",
    a: [
      "Конец массива",
      "Случайную позицию",
      "Начало массива",
      "Начало неотсортированной части"
    ],
    c: 3
  },
  {
    q: "Сортировка пузырьком сравнивает",
    a: [
      "Все элементы сразу",
      "Случайные элементы",
      "Самый большой и самый маленький",
      "Соседние элементы"
    ],
    c: 3
  },
  {
    q: "Сортировка пузырьком заканчивается, когда",
    a: [
      "Выполнено n проходов",
      "Найден минимальный элемент",
      "Достигнут конец массива",
      "За проход не произошло ни одного обмена"
    ],
    c: 3
  },
  {
    q: "Сортировка поразрядно группирует числа по",
    a: [
      "Значению",
      "Индексу",
      "Размеру массива",
      "Разрядам (цифрам)"
    ],
    c: 3
  },
  {
    q: "Быстрая сортировка делит массив на",
    a: [
      "Случайные части",
      "Равные по размеру части",
      "Отсортированные части",
      "Две части относительно опорного элемента"
    ],
    c: 3
  },
  {
    q: "Сортировка слиянием объединяет массив из",
    a: [
      "Несортированных элементов",
      "Случайных частей",
      "Одного массива",
      "Двух отсортированных частей"
    ],
    c: 3
  },
  {
    q: "Сортировка вставками лучше, когда массив",
    a: [
      "Большой и случайный",
      "Полностью неотсортирован",
      "Содержит много дубликатов",
      "Почти отсортирован или небольшой"
    ],
    c: 3
  },
  {
    q: "Быстрая сортировка использует",
    a: [
      "Сравнение соседних элементов",
      "Линейный поиск",
      "Слияние массивов",
      "Опорный элемент (pivot) и разбиение массива"
    ],
    c: 3
  }

  // Add all other questions here...
];

let currentQuestion = 0;
let shuffledQuestions = [];
let circles = [];

// Shuffle function
function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

// Initialize quiz
function startQuiz() {
  currentQuestion = 0;
  shuffledQuestions = shuffleArray([...quizData]);

  // Shuffle answers
  shuffledQuestions.forEach(q => {
    q.shuffledAnswers = shuffleArray(q.a.map((text, idx) => ({ text, idx })));
  });

  // Setup sidebar circles
  const circleBox = document.getElementById("circle-box");
  circleBox.innerHTML = "";
  circles = [];
  for (let i = 0; i < shuffledQuestions.length; i++) {
    const circle = document.createElement("div");
    circle.className = "circle";
    circleBox.appendChild(circle);
    circles.push(circle);
  }

  showQuestion();
}

// Show current question
function showQuestion() {
  const quiz = document.getElementById("quiz");
  quiz.innerHTML = "";
  document.getElementById("nextBtn").disabled = true;

  const item = shuffledQuestions[currentQuestion];
  const qDiv = document.createElement("div");
  qDiv.className = "question";
  qDiv.innerText = `${currentQuestion + 1}. ${item.q}`;
  quiz.appendChild(qDiv);

  const aDiv = document.createElement("div");
  aDiv.className = "answers";

  item.shuffledAnswers.forEach(ans => {
    const label = document.createElement("label");
    const input = document.createElement("input");
    input.type = "radio";
    input.name = `q${currentQuestion}`;
    input.value = ans.idx;

    label.appendChild(input);
    label.append(ans.text);

    input.addEventListener("click", () => {
      if (Number(input.value) === item.c) {
        label.classList.add("correct");
        circles[currentQuestion].classList.add("correct");
      } else {
        label.classList.add("wrong");
        const correctLabel = Array.from(aDiv.querySelectorAll("label")).find(l =>
          l.querySelector("input").value == item.c
        );
        correctLabel.classList.add("correct");
        circles[currentQuestion].classList.add("wrong");
      }

      aDiv.querySelectorAll("input").forEach(inp => inp.disabled = true);
      document.getElementById("nextBtn").disabled = false;
    });

    aDiv.appendChild(label);
  });

  quiz.appendChild(aDiv);
}

// Next button
document.getElementById("nextBtn").addEventListener("click", () => {
  currentQuestion++;
  if (currentQuestion < shuffledQuestions.length) {
    showQuestion();
  } else {
    document.getElementById("quiz").innerHTML = "<h2>Вы завершили тест!</h2>";
    document.getElementById("nextBtn").disabled = true;
  }
});

// Start quiz on load
startQuiz();
</script>

</body>
</html>






